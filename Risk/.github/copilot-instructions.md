<!-- Autogenerated guidance for AI coding agents working on this repo. -->
# Copilot / AI Agent Instructions

This is a small C# console implementation of a grid-based Risk-like game. The goal of this file is to give an AI coding agent the concise, repository-specific knowledge needed to be productive immediately.

1. Big picture
- **Project type**: single-process .NET console app. The playable game is implemented under `ConsoleApp1/` and targets `net9.0` (see `obj/Debug/net9.0`).
- **Main orchestrator**: `ConsoleApp1/Game.cs` contains the game loop (`GameLoop`) and the `Main` entry at file bottom. Treat `Game` as the controller for turns, phases (reinforce, attack, fortify) and player input.
- **Model classes**: `Board.cs` (2D `Territory[,]` grid), `Territory.cs` (name, owner, armies, land type), `Player.cs` (combat, reinforce, attack, fortify). `Computer.cs` is currently empty (placeholder for AI player behaviors).
- **Data flow**: `Game` creates a `Board` (rows × cols), populates `Territory` objects, assigns starting territories to `Player`s, and then updates territories and armies in-place via `Territory` methods. There is no external persistence or service boundary.

2. Key files to review or modify
- `ConsoleApp1/Game.cs`: game loop, turn management, input parsing and high-level flow.
- `ConsoleApp1/Board.cs`: grid container and `DisplayBoard()` logic.
- `ConsoleApp1/Territory.cs`: single-territory API (`GetOwner`, `AddArmy`, `RemoveArmy`, `SetLandType`).
- `ConsoleApp1/Player.cs`: combat rules and player actions.
- `ConsoleApp1/Computer.cs`: implement AI decision making here.

3. Build / run / debug
- Build: `dotnet build ConsoleApp1/ConsoleApp1.csproj` or from repo root `dotnet build ConsoleApp1`
- Run: `dotnet run --project ConsoleApp1` (this will invoke `new Game().GameLoop()` from `Game.cs`)
- No unit tests are present. Add tests under a new test project if needed.

4. Project-specific patterns & conventions
- **Grid adjacency**: adjacency is implicit (grid neighbors including diagonals). There is no adjacency list — if you change adjacency logic, update both `Game` validation and any combat/attack/ferry logic.
- **Territory identity**: territories are referenced by a textual name (e.g., `"0a0"`) and by grid coordinates. Many `Game` methods iterate rows/cols to find a territory by name — consider adding a lookup helper if you need performance or clarity.
- **Mutability**: `Territory` objects are mutated in-place (owner and armies changed directly). Keep this in mind when refactoring (avoid creating copies unintentionally).
- **Input parsing**: `Game.GetAttackInput()` and `GetFortifyInput()` expect comma-separated inputs (e.g., `"1a1, 2a2, 3"`). Be defensive: guard against null/empty and malformed splits before parsing ints.

5. Common pitfalls discovered (be cautious)
- `Program.cs` is effectively empty; the actual `Main` is in `Game.cs`. Do not assume `Program.cs` is the entry point.
- Several places in `Game.cs` use ranges or C# shorthand that may not compile as-is (e.g., list literals `[]` or slice-like `[..]`). Verify compile before trusting runtime behavior.
- Random index usage: some `Random.Next` calls use `Next(1, rows)` which excludes row 0; check for off-by-one issues when placing terrain or starting territories.

6. Suggested small improvements an agent can make safely
- Add a `Board.GetTerritoryByName(string)` helper to avoid repetitive nested loops in `Game`.
- Move input parsing into a small `InputParser` helper to centralize validation and error messages.
- Implement `Computer` AI as a subclass of `Player` or an interface so `Game` can treat human and computer players uniformly.

7. When submitting changes / PR checks
- Ensure `dotnet build ConsoleApp1` succeeds locally. Include short runnable examples in a PR description if you modify gameplay.
- Keep changes focused: this repository is small — prefer minimal, testable commits that update only one concern (e.g., parsing helper, board lookup, AI behavior).

If anything in this document is unclear or you want the file to include extra details (e.g., coding conventions, naming rules, or tests to add), tell me what to expand and I will iterate.
